<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>オッズ異常解析ツール</title>
    <style>
        .grid_container {
            display: grid;
            width: max-content;
            height: max-content;
            grid-template-columns: 40px 40px 50px repeat(4, 50px) ;
            grid-template-rows: repeat(20, 25px);
            gap: 0;
            border-top: none;
            border-left: none;
            border-right:  1px solid black;
            border-bottom: 1px solid black;
        }
        .grid-item {
            border-top: 1px solid black;                          /* 上に境界線なし */
            border-left: 1px solid black;                         /* 左に境界線なし */
            border-right: none;             /* 右に境界線 */
            border-bottom: none;            /* 下に境界線 */
            text-align: center;                        /* テキストの中央揃え */
            overflow: hidden;                          /* テキストがセルを超えないようにする */
            white-space: nowrap;                       /* テキストを折り返さない */
            box-sizing: border-box;                    /* ボーダーを含めたサイズ計算 */
        }
        .large-text {
            font-size: 2em;
            font-weight: bold;
        }
        .medium-text {
            font-size: 1.25em;
        }
        .gold {
            background: linear-gradient(0deg, #b89851, #ffd700, #fff8dc, #c5a66f); /* 145degから90degに変更して縦長に対応 */
            box-shadow: inset 0 0 25px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 223, 0, 0.6), 0 10px 25px rgba(0, 0, 0, 0.2); /* シャドウの範囲を広く */
        }
        .silver {
            background: linear-gradient(0deg, #a1a1a1, #d4d4d4, #f1f1f1, #8d8d8d);
            box-shadow: inset 0 0 25px rgba(192, 192, 192, 0.8), 0 0 30px rgba(224, 224, 224, 0.6), 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        .bronze {
            background: linear-gradient(0deg, #d98a52, #e0a577, #fae2d1, #e6a472);
            box-shadow: inset 0 0 20px rgba(227, 155, 100, 0.6), 0 0 25px rgba(255, 195, 113, 0.8), 0 8px 20px rgba(0, 0, 0, 0.2);
        }
        #inputA {
            display: block;
        }
        #inputB {
            display: none;
        }
        #inputC {
            display: none;
        }
        #slider {
            width: 450px;
        }
        #cont{
            display: none;
        }
    </style>
</head>
<body>



<form id="text">
    <label for="inputA">上位人気一覧</label><br>
    <textarea id="inputA" name="inputA" rows="10" cols="50"></textarea><br><br>
    
    <label for="inputB">3連複</label><br>
    <textarea id="inputB" name="inputB" rows="10" cols="50"></textarea><br><br>
</form>

<div id="Title"></div>

<div style="display: flex;">
    <div class="grid_container">
        <div class="grid-item">馬番</div>
        <div class="grid-item">人気</div>
        <div class="grid-item">賛成</div>
        <div class="grid-item">信頼%</div>
        <div class="grid-item">逆張</div>
        <div class="grid-item">単勝</div>
        <div class="grid-item">複勝%</div>
    </div>
</div>

<div id="cont">
    <br>
    逆張り定数
    <input type="range" id="slider" min="0" max="0.05" step="0.001" value="0">
</div>

<div id="url">
    <br><br><br><br>
</div>

<script src="https://cdn.jsdelivr.net/npm/mathjs@latest/lib/browser/math.js"></script>

<script>
    const slider = document.getElementById('slider');
    const colors = ['lightgray', 'red', 'black'];
    let colorIndex = Array(18).fill(2); // 各列の色インデックスを管理（デフォルトは黒）
    let grid_container;
    let BoteFuku=[];
    let N_uma = 0;
    let N_cancel = 0;
    let N_all = 0;
    let BBBsum = 0;
    let TableA_Odds_and_Name=[];
    let sanren_fuku_sum=0;
    // Mapを使用してデータを格納
    const sanren_fuku = new Map();
    let sanren_fuku_sum_for_i = Array(18).fill(0);



    window.onload = function() {
        //グリッド生成
        make_grid();
        netkeibaURL();
        //二つの親要素取得。後程childrenメソッドで中身を操作する。
        grid_container = document.querySelector(".grid_container");
        //各イベントリスナー設定
        slider.addEventListener('input', analyze);
        let timer;
        document.getElementById('inputA').addEventListener('input', () => {
            clearTimeout(timer);
            timer = setTimeout(processInputA, 500);
        });
        document.getElementById('inputB').addEventListener('input', () => {
            clearTimeout(timer);
            timer = setTimeout(processInputB, 500);
        });
        grid_container.addEventListener('click', (event) => {
            if (event.target.classList.contains('grid-item')) {
                const row = event.target.dataset.row;
                colorIndex[row] = (colorIndex[row] + 1) % colors.length;
                const cells = document.querySelectorAll(`.grid-item[data-row='${row}']`);
                cells.forEach(cell => {
                    cell.style.color = colors[colorIndex[row]];
                });
            }
        });
    };







    window.onbeforeunload = function(event) {
        event.preventDefault();
        event.returnValue = 'このページを離れようとしています。入力データは初期化されます';
    };

    function make_grid() {
        let gc = document.querySelector(".grid_container");
        const rows = 19;
        const cols = 7;

        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-item');
                cell.dataset.row=i;
                cell.dataset.col=j;
                const uma_ban = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮', '⑯', '⑰', '⑱', '合計'];
                if(j==0){
                    cell.textContent=uma_ban[i]
                }
                gc.appendChild(cell);
            }
        }
    }

    function netkeibaURL(){
        // 現在の年月日を取得
        const today = new Date();
        const year = today.getFullYear();
        const month = ('0' + (today.getMonth() + 1)).slice(-2); // 月は0から始まるので+1
        const day = ('0' + today.getDate()).slice(-2);

        // yyyymmddの形に整形
        const kyou = `${year}${month}${day}`;

        // URLを作成
        const url = `https://race.netkeiba.com/top/?kaisai_date=${kyou}`;

        // HTMLの一番最後にURLを表示
        const a = document.createElement('a');
        a.href = url;
        a.target = "_blank"; // 新しいタブで開くように設定
        a.textContent = url;
        document.getElementById('url').appendChild(a);
    }


    function solveEquations(D, U) {
        const N = D.length;
        const th_sum = 1;

        // 1. Dを二次元配列に拡張
        let D_extended = D.map((di, i) => [di, i]);

        // 2. DをソートしてCを作成
        let C = D_extended.sort((a, b) => {
        if (a[0] === b[0]) {
            if (U[a[0]] === U[b[0]]) {
            return a[1] - b[1]; // インデックス順でソート
            } else {
            return U[a[0]] - U[b[0]]; // Uの値でソート
            }
        } else {
            return a[0] - b[0]; // Dの値でソート
        }
        });

        // 3. Nに応じて線形連立方程式を設定し解く
        let A = [];
        let b = [];
        if (N >= 8) {
        let a = 3.75;
        // 1つ目の方程式
        A.push([(a * C[0][0] - 2), 1, 1, ...Array(N - 3).fill(0)]);
        b.push(th_sum);

        // 2つ目の方程式
        A.push([1, (a * C[1][0] - 2), 1, ...Array(N - 3).fill(0)]);
        b.push(th_sum);

        // 3つ目以降の方程式
        for (let i = 2; i < N; i++) {
            let row = Array(N).fill(0);
            row[0] = 1;
            row[1] = 1;
            row[i] = (a * C[i][0] - 2);
            A.push(row);
            b.push(th_sum);
        }
        } else {
        let a = 2.5;
        // 1つ目の方程式
        A.push([(a * C[0][0] - 1), 1, ...Array(N - 2).fill(0)]);
        b.push(th_sum);

        // 2つ目以降の方程式
        for (let i = 1; i < N; i++) {
            let row = Array(N).fill(0);
            row[0] = 1;
            row[i] = (a * C[i][0] - 1);
            A.push(row);
            b.push(th_sum);
        }
        }

        // 連立方程式を解く
        let X = math.lusolve(A, b);

        // 4. Cに解を挿入
        for (let i = 0; i < N; i++) {
        C[i].push(X[i][0]);
        }

        // 5. C[i][1]が小さい順にソートした配列Bを作成
        let B = C.sort((a, b) => a[1] - b[1]);

        // 6. B[i][2]と、その総和を表示
        let sum = 0;
        B.forEach((row) => {
        sum += row[2];
        });

        return B.map(row => row[2]/sum);
    }

    function processInputA() {
        let inputA=document.getElementById('inputA');        
        const input = inputA.value;
        inputA.style.display="none";

        //正規表現の定義
        const regex_Title = /1R\n2R\n3R\n4R\n5R\n6R\n7R\n8R\n9R\n10R\n11R\n12R\n(\d+R)\n(.+)\n(.+)\n(.+)\n/g;
        const regex_name_odds=/(\d+)\s\d\s(\d+)\s\n(\S+)\s(\d+.\d)\s(\d+.\d)\s-\s(\d+.\d)\n/g;
        const regex_Cancel=/--\s\d\s(\d+)\s\s(\S+)\s(除外|取消)\n/g;

        //tableA作成
        let match_name_odds;
        while ((match_name_odds = regex_name_odds.exec(input)) !== null) {
            TableA_Odds_and_Name.push([match_name_odds[2], match_name_odds[3], match_name_odds[1], match_name_odds[4], match_name_odds[5], match_name_odds[6]]);
        }

        //除外&取消検索
        let match_Cancel;
        let TableA_Cancel=[];
        while ((match_Cancel = regex_Cancel.exec(input)) !== null) {
            TableA_Cancel.push([match_Cancel[1], match_Cancel[2], match_Cancel[3], Infinity, Infinity, Infinity]);
        }

        //tableAに結合
        TableA_Cancel.forEach(item => TableA_Odds_and_Name.push(item));
        TableA_Odds_and_Name.sort((a, b) => a[0] - b[0]);
        N_uma=TableA_Odds_and_Name.length;
        N_cancel=TableA_Cancel.length;
        let N_run=N_uma-N_cancel;
        N_all = N_run * (N_run - 1) * (N_run - 2) / 6;

        //タイトル記述
        const match_Title = regex_Title.exec(input);
        if (match_Title) {
            const Title = `
                <div class="large-text">【${match_Title[1]}】${match_Title[2]}</div>
                <div class="medium-text">${match_Title[3]}</div>
                <div class="medium-text">${match_Title[4]}</div>
            `;
            document.getElementById('Title').innerHTML = Title;
        } else {
            document.getElementById('Title').innerHTML = "正規表現に一致するテキストが見つかりませんでした。";
        }

        //複勝%
        let D = TableA_Odds_and_Name.map(row => row[4]);
        let U = TableA_Odds_and_Name.map(row => row[5]);
        BoteFuku=solveEquations(D,U);


        //３項積総和
        for (let i = 0; i < N_uma; i++) {
            for (let j = 0; j < i; j++) {
                for (let k = 0; k < j; k++) {
                    BBBsum += BoteFuku[i] * BoteFuku[j] * BoteFuku[k];
                }
            }
        }

        //単勝オッズ等書き込み
        for (let i = 0; i < N_uma; i++) {
            const rowStartIndex = (i+1)*7;
            let ninki=TableA_Odds_and_Name[i][2];
            let TanOdds = TableA_Odds_and_Name[i][3];

            grid_container.children[rowStartIndex+1].textContent = ninki;

            if (TanOdds!==Infinity){
                grid_container.children[rowStartIndex+5].textContent = TanOdds;
                grid_container.children[rowStartIndex+6].textContent = (BoteFuku[i]*100).toFixed(1);
            }

            //ハイライト処理
            if(ninki==1){
                grid_container.children[rowStartIndex].classList.add("gold");
                grid_container.children[rowStartIndex+1].classList.add("gold");
                grid_container.children[rowStartIndex+5].classList.add("gold");
            }
            if(ninki==2){
                grid_container.children[rowStartIndex].classList.add("silver");
                grid_container.children[rowStartIndex+1].classList.add("silver");
                grid_container.children[rowStartIndex+5].classList.add("silver");
            }
            if(ninki==3){
                grid_container.children[rowStartIndex].classList.add("bronze");
                grid_container.children[rowStartIndex+1].classList.add("bronze");
                grid_container.children[rowStartIndex+5].classList.add("bronze");
            }
        }
        grid_container.children[7*19+6].textContent = (BoteFuku.reduce((acc, val) => acc + val, 0)*100).toFixed(1);




        //B表示
        document.getElementById('inputB').style.display="block";
    }

    function processInputB() {
        // 入力テキストの取得
        let inputB= document.getElementById('inputB')
        const input = inputB.value;
        inputB.style.display="none";

        // メインの正規表現マッチング
        const match = input.match(/オッズを見て個別に選択全選択全解除\n選択\n([\s\S]+?)\n選択済み/);

        if (match) {
            // 内部テキストの取得
            const innerText = match[1];
            const innerRegex = /(\d+)\n\s\s\n(\d+)\n\s\s\n(\d+)\n(\d+\.\d+)/g;
            let innerMatch;

            // 内部の正規表現でデータを抽出
            while ((innerMatch = innerRegex.exec(innerText)) !== null) {
                // i, j, k の順序は既に i < j < k と確定しているため、そのまま使用
                const i = +innerMatch[1] - 1;
                const j = +innerMatch[2] - 1;
                const k = +innerMatch[3] - 1;
                const X = 7500 / +innerMatch[4] / 10000; // 必要な逆数計算を一度に実行

                sanren_fuku_sum += X;

                // i, j, k をキーとして連結
                const key = `${i},${j},${k}`;
                // X を Map に格納
                sanren_fuku.set(key, X);
            }
        } else {
            console.log("指定されたパターンが見つかりませんでした。");
        }

        analyze();

        document.getElementById('cont').style.display="block";
    }

    function analyze(){
        // alphaの計算
        const meter = +slider.value;
        const cont = meter/N_all;
        const alpha = (sanren_fuku_sum - meter ) / BBBsum;

        // Delta_Re_Th, Th_sum, support, oppose の計算
        let support = new Array(N_uma).fill(0);
        let oppose = new Array(N_uma).fill(0);
        let reals = new Array(N_uma).fill(0);
        let denger = new Array(N_uma).fill(0);

        for (let i = 0; i < N_uma; i++) {
            for (let j = 0; j < i; j++) {
                for (let k = 0; k < j; k++) {
                    // キー連結
                    const key = `${k},${j},${i}`;
                    // Map からX を取得
                    let re = sanren_fuku.get(key);                 
                    const bbb = BoteFuku[i]*BoteFuku[j]*BoteFuku[k];
                    let th = alpha * bbb + cont;
                    
                    if (re==undefined){re = 0; th=0;}
                    const delta = re - th;

                    for (let p of [i,j,k]) {     
                        reals[p]+=re;
                        if (delta > 0) {
                            support[p] += delta;
                        } else if (delta < 0) {
                            oppose[p] += delta;
                        }
                    }
                }
            }
        }

        //記入処理
        for (let i = 0; i < N_uma; i++) {
            const i_start=7*(i+1);
            const sup=100*support[i];
            const opp=100*oppose[i];
            const rel=100*sup/(sup-opp);
            if(TableA_Odds_and_Name[i][3]!==Infinity){
                grid_container.children[i_start+2].textContent = sup.toFixed(1);
                grid_container.children[i_start+3].textContent = rel.toFixed(1);
                grid_container.children[i_start+4].textContent = (sup/reals[i]).toFixed(1);
            }
        }
    }













</script>

</body>
</html>

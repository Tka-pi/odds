<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>オッズ異常解析ツール</title>
    <style>
        .grid_container {
            display: grid;
            width: max-content;
            height: max-content;
            grid-template-columns: 40px 40px repeat(9, 55px) ;
            grid-template-rows: repeat(20, 25px);
            gap: 0;
            border-top: none;
            border-left: none;
            border-right:  1px solid black;
            border-bottom: 1px solid black;
        }
        .grid-item {
            border-top: 1px solid black;                          /* 上に境界線なし */
            border-left: 1px solid black;                         /* 左に境界線なし */
            border-right: none;             /* 右に境界線 */
            border-bottom: none;            /* 下に境界線 */
            text-align: center;                        /* テキストの中央揃え */
            overflow: hidden;                          /* テキストがセルを超えないようにする */
            white-space: nowrap;                       /* テキストを折り返さない */
            box-sizing: border-box;                    /* ボーダーを含めたサイズ計算 */
        }
        .large-text {
            font-size: 2em;
            font-weight: bold;
        }
        .medium-text {
            font-size: 1.25em;
        }
        .gold {
            background: linear-gradient(0deg, #b89851, #ffd700, #fff8dc, #c5a66f); /* 145degから90degに変更して縦長に対応 */
            box-shadow: inset 0 0 25px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 223, 0, 0.6), 0 10px 25px rgba(0, 0, 0, 0.2); /* シャドウの範囲を広く */
        }
        .silver {
            background: linear-gradient(0deg, #a1a1a1, #d4d4d4, #f1f1f1, #8d8d8d);
            box-shadow: inset 0 0 25px rgba(192, 192, 192, 0.8), 0 0 30px rgba(224, 224, 224, 0.6), 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        .bronze {
            background: linear-gradient(0deg, #d98a52, #e0a577, #fae2d1, #e6a472);
            box-shadow: inset 0 0 20px rgba(227, 155, 100, 0.6), 0 0 25px rgba(255, 195, 113, 0.8), 0 8px 20px rgba(0, 0, 0, 0.2);
        }
        #inputA {
            display: block;
        }
        #inputB {
            display: none;
        }
        #inputC {
            display: none;
        }
        #slider {
            width: 450px;
        }
        #cont{
            display: none;
        }
    </style>
</head>
<body>



<form id="text">
    <label for="inputA">上位人気一覧</label><br>
    <textarea id="inputA" name="inputA" rows="10" cols="50"></textarea><br><br>
    
    <label for="inputB">3連単</label><br>
    <textarea id="inputB" name="inputB" rows="10" cols="50"></textarea><br><br>
</form>

<div id="Title"></div>

<div style="display: flex;">
    <div class="grid_container">
        <div class="grid-item">馬番</div>
        <div class="grid-item">人気</div>
        <div class="grid-item">単勝o.</div>
        <div class="grid-item">本命度</div>
        <div class="grid-item">信頼度</div>
        <div class="grid-item">1st</div>
        <div class="grid-item">信頼度</div>
        <div class="grid-item">2nd</div>
        <div class="grid-item">信頼度</div>
        <div class="grid-item">3rd</div>
        <div class="grid-item">信頼度</div>
    </div>
</div>

<div id="cont">
    <br>
    逆張り定数
    <input type="range" id="slider" min="0" max="0.05" step="0.001" value="0">
</div>

<div id="url" style="margin-bottom: 100px;">
    <br><br><br><br><a href="https://www.ipat.jra.go.jp/" target="_blank">ネット投票</a><br><br><br>
</div>

<script src="https://cdn.jsdelivr.net/npm/mathjs@latest/lib/browser/math.js"></script>

<script>
    //グローバル変数をなくす？
    const colors = ['lightgray', 'red', 'black'];
    let colorIndex = Array(18).fill(2);
    let Re_fuku=[];
    let Re_tan=[];
    let N_uma = 0;
    let N_cancel = 0;
    let N_all = 0;
    let BBBsum = 0;
    let TableA_Odds_and_Name=[];
    let sanren_tan_sum=0;
    const sanren_tan = new Map();




    window.onload = function() {
        //グリッド生成
        make_grid();
        netkeibaURL();
        //各イベントリスナー設定
        document.getElementById('slider').addEventListener('input', analyze);
        let timer;
        document.getElementById('inputA').addEventListener('input', () => {
            clearTimeout(timer);
            timer = setTimeout(processInputA, 500);
        });
        document.getElementById('inputB').addEventListener('input', () => {
            clearTimeout(timer);
            timer = setTimeout(processInputB, 500);
        });
        document.querySelector(".grid_container").addEventListener('click', (event) => {
            if (event.target.classList.contains('grid-item')) {
                const row = event.target.dataset.row;
                colorIndex[row] = (colorIndex[row] + 1) % colors.length;
                const cells = document.querySelectorAll(`.grid-item[data-row='${row}']`);
                cells.forEach(cell => {
                    cell.style.color = colors[colorIndex[row]];
                });
                analyze();
            }
        });
    };

    window.onbeforeunload = function(event) {
        event.preventDefault();
        event.returnValue = 'このページを離れようとしています。入力データは初期化されます';
    };

    function make_grid() {
        let gc = document.querySelector(".grid_container");
        const rows = 19;
        const cols = 11;

        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-item');
                cell.dataset.row=i;
                cell.dataset.col=j;
                const uma_ban = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮', '⑯', '⑰', '⑱', '合計'];
                if(j==0){
                    cell.textContent=uma_ban[i]
                }
                if(j%2==0){
                    cell.style.backgroundColor="whitesmoke";
                }
                gc.appendChild(cell);
            }
        }
    }

    function netkeibaURL(){
        // 現在の年月日を取得
        const today = new Date();
        const year = today.getFullYear();
        const month = ('0' + (today.getMonth() + 1)).slice(-2); // 月は0から始まるので+1
        const day = ('0' + today.getDate()).slice(-2);

        // yyyymmddの形に整形
        const kyou = `${year}${month}${day}`;

        // URLを作成
        const url = `https://race.netkeiba.com/top/?kaisai_date=${kyou}`;

        // HTMLの一番最後にURLを表示
        const a = document.createElement('a');
        a.href = url;
        a.target = "_blank"; // 新しいタブで開くように設定
        a.textContent = url;
        document.getElementById('url').appendChild(a);
    }


    function solveEquations(D, U) {
        const N = D.length;
        const th_sum = 1;

        // 1. Dを二次元配列に拡張
        let D_extended = D.map((di, i) => [di, i]);

        // 2. DをソートしてCを作成
        let C = D_extended.sort((a, b) => {
        if (a[0] === b[0]) {
            if (U[a[0]] === U[b[0]]) {
            return a[1] - b[1]; // インデックス順でソート
            } else {
            return U[a[0]] - U[b[0]]; // Uの値でソート
            }
        } else {
            return a[0] - b[0]; // Dの値でソート
        }
        });

        // 3. Nに応じて線形連立方程式を設定し解く
        let A = [];
        let b = [];
        if (N >= 8) {
        let a = 3.75;
        // 1つ目の方程式
        A.push([(a * C[0][0] - 2), 1, 1, ...Array(N - 3).fill(0)]);
        b.push(th_sum);

        // 2つ目の方程式
        A.push([1, (a * C[1][0] - 2), 1, ...Array(N - 3).fill(0)]);
        b.push(th_sum);

        // 3つ目以降の方程式
        for (let i = 2; i < N; i++) {
            let row = Array(N).fill(0);
            row[0] = 1;
            row[1] = 1;
            row[i] = (a * C[i][0] - 2);
            A.push(row);
            b.push(th_sum);
        }
        } else {
        let a = 2.5;
        // 1つ目の方程式
        A.push([(a * C[0][0] - 1), 1, ...Array(N - 2).fill(0)]);
        b.push(th_sum);

        // 2つ目以降の方程式
        for (let i = 1; i < N; i++) {
            let row = Array(N).fill(0);
            row[0] = 1;
            row[i] = (a * C[i][0] - 1);
            A.push(row);
            b.push(th_sum);
        }
        }

        // 連立方程式を解く
        let X = math.lusolve(A, b);

        // 4. Cに解を挿入
        for (let i = 0; i < N; i++) {
        C[i].push(X[i][0]);
        }

        // 5. C[i][1]が小さい順にソートした配列Bを作成
        let B = C.sort((a, b) => a[1] - b[1]);

        // 6. B[i][2]と、その総和を表示
        let sum = 0;
        B.forEach((row) => {
        sum += row[2];
        });

        return B.map(row => row[2]/sum);
    }

    function processInputA() {
        let inputA=document.getElementById('inputA');        
        const input = inputA.value;
        inputA.style.display="none";

        //正規表現の定義
        const regex_Title = /1R\n2R\n3R\n4R\n5R\n6R\n7R\n8R\n9R\n10R\n11R\n12R\n(\d+R)\n(.+)\n(.+)\n(.+)\n/g;
        const regex_name_odds=/(\d+)\s\d\s(\d+)\s\n(\S+)\s(\d+.\d)\s(\d+.\d)\s-\s(\d+.\d)\n/g;
        const regex_Cancel=/--\s\d\s(\d+)\s\s(\S+)\s(除外|取消)\n/g;

        //tableA作成
        let match_name_odds;
        while ((match_name_odds = regex_name_odds.exec(input)) !== null) {
            TableA_Odds_and_Name.push([match_name_odds[2], match_name_odds[3], match_name_odds[1], match_name_odds[4], match_name_odds[5], match_name_odds[6]]);
        }

        //除外&取消検索
        let match_Cancel;
        let TableA_Cancel=[];
        while ((match_Cancel = regex_Cancel.exec(input)) !== null) {
            TableA_Cancel.push([match_Cancel[1], match_Cancel[2], match_Cancel[3], Infinity, Infinity, Infinity]);
        }

        //tableAに結合
        TableA_Cancel.forEach(item => TableA_Odds_and_Name.push(item));
        TableA_Odds_and_Name.sort((a, b) => a[0] - b[0]);
        N_uma=TableA_Odds_and_Name.length;
        N_cancel=TableA_Cancel.length;
        let N_run=N_uma-N_cancel;
        N_all = N_run * (N_run - 1) * (N_run - 2) / 6;

        //タイトル記述
        const match_Title = regex_Title.exec(input);
        if (match_Title) {
            const Title = `
                <div class="large-text">【${match_Title[1]}】${match_Title[2]}</div>
                <div class="medium-text">${match_Title[3]}</div>
                <div class="medium-text">${match_Title[4]}</div>
            `;
            document.getElementById('Title').innerHTML = Title;
        } else {
            document.getElementById('Title').innerHTML = "正規表現に一致するテキストが見つかりませんでした。";
        }

        //Re_tan生成
        let tan=TableA_Odds_and_Name.map(row => 1/row[3]);
        let tan_sum=tan.reduce((acc, curr) => acc + curr, 0);
        Re_tan=tan.map(a=>a/tan_sum);

        //複勝%
        let D = TableA_Odds_and_Name.map(row => row[4]);
        let U = TableA_Odds_and_Name.map(row => row[5]);
        Re_fuku=solveEquations(D,U);


        //３項積総和
        for (let i = 0; i < N_uma; i++) {
            for (let j = 0; j < i; j++) {
                for (let k = 0; k < j; k++) {
                    BBBsum += Re_fuku[i] * Re_fuku[j] * Re_fuku[k];
                }
            }
        }

        const grid_container=document.querySelector(".grid_container");

        //単勝オッズ等書き込み
        for (let i = 0; i < N_uma; i++) {
            const rowStartIndex = (i+1)*11;
            let ninki=TableA_Odds_and_Name[i][2];
            let TanOdds = TableA_Odds_and_Name[i][3];
            

            grid_container.children[rowStartIndex+1].textContent = ninki;

            if (TanOdds!==Infinity){
                grid_container.children[rowStartIndex+2].textContent = TanOdds;
            }

            //ハイライト処理
            if(ninki==1){
                grid_container.children[rowStartIndex].classList.add("gold");
                grid_container.children[rowStartIndex+1].classList.add("gold");
                grid_container.children[rowStartIndex+2].classList.add("gold");
            }
            if(ninki==2){
                grid_container.children[rowStartIndex].classList.add("silver");
                grid_container.children[rowStartIndex+1].classList.add("silver");
                grid_container.children[rowStartIndex+2].classList.add("silver");
            }
            if(ninki==3){
                grid_container.children[rowStartIndex].classList.add("bronze");
                grid_container.children[rowStartIndex+1].classList.add("bronze");
                grid_container.children[rowStartIndex+2].classList.add("bronze");
            }
        }


        //B表示
        document.getElementById('inputB').style.display="block";
    }

    function processInputB() {
        // 入力テキストの取得
        let inputB= document.getElementById('inputB')
        const input = inputB.value;
        //inputB.style.display="none";

        // メインの正規表現マッチング
        const match = input.match(/オッズを見て個別に選択全選択全解除\n選択\n([\s\S]+?)\n選択済み/);

        if (match) {
            // 内部テキストの取得
            const innerText = match[1];
            const innerRegex = /(\d+)\n\s\s\n(\d+)\n\s\s\n(\d+)\n(\d+\.\d+)/g;
            let innerMatch;

            // 内部の正規表現でデータを抽出
            while ((innerMatch = innerRegex.exec(innerText)) !== null) {
                //ijkがそのまま着順。
                const i = +innerMatch[1] - 1;
                const j = +innerMatch[2] - 1;
                const k = +innerMatch[3] - 1;
                const X = 725000 / +innerMatch[4] / 1000000; // 必要な逆数計算を一度に実行

                sanren_tan_sum += X;
                sanren_tan.set(`${i},${j},${k}`, X);
            }
            //規格化微調整
            sanren_tan.forEach((value, key) => {
                sanren_tan.set(key, value / sanren_tan_sum);
            });

        } else {
            console.log("指定されたパターンが見つかりませんでした。");
        }

        analyze();

        //document.getElementById('cont').style.display="block";
    }

    function analyze(){
        // alphaの計算

        const meter = document.querySelector("#slider").value;
        const cont = meter/N_all;
        const alpha = (1 - meter ) / BBBsum;

        //[馬番][0=三連複,n=n着]
        let support= Array.from({ length: N_uma }, () => Array(4).fill(0));
        let oppose= Array.from({ length: N_uma }, () => Array(4).fill(0));

        for (let i = 0; i < N_uma; i++) {
            for (let j = 0; j < N_uma; j++) {
                for (let k = 0; k < N_uma; k++) {
                    const re_tan = sanren_tan.get(`${i},${j},${k}`);

                    if (re_tan!==undefined){
                        const th_tan = Re_tan[i]*Re_tan[j]*Re_tan[k]/(1-Re_tan[i])/(1-Re_tan[i]-Re_tan[j]);
                        const delta_tan = re_tan-th_tan;

                        if(delta_tan>0){
                            support[i][1]+=delta_tan;
                            support[j][2]+=delta_tan;
                            support[k][3]+=delta_tan;
                        }else if(delta_tan<0){
                            oppose[i][1]+=delta_tan;
                            oppose[j][2]+=delta_tan;
                            oppose[k][3]+=delta_tan;
                        }
                    }
                }               
            }
        }


        for (let i = 0; i < N_uma; i++) {
            for (let j = 0; j < i; j++) {
                for (let k = 0; k < j; k++) {
                    const re_fuku = sanren_tan.get(`${i},${j},${k}`)+
                                    sanren_tan.get(`${i},${k},${j}`)+
                                    sanren_tan.get(`${j},${i},${k}`)+
                                    sanren_tan.get(`${j},${k},${i}`)+
                                    sanren_tan.get(`${k},${i},${j}`)+
                                    sanren_tan.get(`${k},${j},${i}`);

                    if (re_fuku>0){
                        const th_fuku = alpha*Re_fuku[i]*Re_fuku[j]*Re_fuku[k];
                        const delta_fuku = re_fuku-th_fuku;


                        if(delta_fuku>0){
                            support[i][0]+=delta_fuku;
                            support[j][0]+=delta_fuku;
                            support[k][0]+=delta_fuku;
                        }else if(delta_fuku<0){
                            oppose[i][0]+=delta_fuku;
                            oppose[j][0]+=delta_fuku;
                            oppose[k][0]+=delta_fuku;
                        }
                    }
                }               
            }
        }


        //記入処理
        let gc = document.querySelector(".grid_container");
        for (let i = 0; i < N_uma; i++) {
            if(TableA_Odds_and_Name[i][3]!==Infinity){
                const i_start=11*(i+1);
                for (let j = 0; j < 4; j++) {
                    //gc.children[i_start+3+2*j].textContent = (100*percentage(support.map(row=>row[j]))[i]).toFixed(1);
                    gc.children[i_start+3+2*j].textContent = (100*support[i][j]).toFixed(1);
                    gc.children[i_start+4+2*j].textContent = (100*support[i][j]/(support[i][j]-oppose[i][j])).toFixed(0)+"%";
                }
            }
        }
    }


    function checkStyle(i) {
        // 10*(i+1)番目の子要素を取得
        const element = document.querySelector(`.grid_container :nth-child(${10*i+8})`);
        
        // 要素が存在し、スタイルが"color: lightgray;"であるかを確認
        if (element && element.style.color === "lightgray") {
            return 0;
        }
        return 1;
    }

    function score(arr) {
        // 平均値を計算
        const mean = arr.reduce((sum, value) => sum + value, 0) / arr.length;

        // 標準偏差を計算
        const stdDev = Math.sqrt(arr.map(value => (value - mean) ** 2).reduce((sum, value) => sum + value, 0) / arr.length);

        // 偏差値を計算
        return arr.map(value => 50 + 10 * (value - mean) / stdDev);
    }

    function percentage(arr) {
        // 配列の合計を計算
        const total = arr.reduce((sum, value) => sum + value, 0);

        // 各成分の割合を計算
        return arr.map(value => value / total);
    }











</script>

</body>
</html>
